{"version":3,"sources":["anim-scroll.js"],"names":["window","addEventListener","delay","duration","sections","Array","prototype","slice","call","document","querySelectorAll","state","lastScrollTime","lastAF","startY","currentTargetSection","simulated","getCurrentSection","retEl","min","Math","abs","getBoundingClientRect","y","i","length","distance","animateScroll","target","t","Date","now","curveY","newScrollTop","round","deltaY","scroll","requestAnimationFrame","cancelAnimationFrame","clearTimeout","lastTimeout","pageYOffset","setTimeout","passive"],"mappings":"AA+DAA,OAAOC,iBAAiB,OA/DI,KACxB,MAAMC,EAAQ,IACRC,EAAW,IAEjB,IAAIC,EAAWC,MAAMC,UAAUC,MAAMC,KAAKC,SAASC,iBAAiB,2BAEhEC,EAAQ,CACRC,gBAAiB,EACjBC,QAAS,EACTC,QAAS,EACTC,qBAAsB,KACtBC,WAAW,GAoBf,SAASC,IACL,IAAIC,EAAQd,EAAS,GACjBe,EAAMC,KAAKC,IAAIH,EAAMI,wBAAwBC,GACjD,IAAK,IAAIC,EAAI,EAAGA,EAAIpB,EAASqB,OAAQD,IAAK,CACtC,MAAME,EAAWN,KAAKC,IAAIjB,EAASoB,GAAGF,wBAAwBC,GAC9D,GAAIG,EAAWP,EACX,OAAOD,EAEXC,EAAMO,EACNR,EAAQd,EAASoB,GAErB,OAAON,EAGX,SAASS,EAAcC,GACnB,MAEMC,GAFQC,KAAKC,MAAQpB,EAAMC,eAAiBV,GAEhCC,EAEZ6B,EAAS,GAAK,EAAIH,GAAKA,EAAIA,GAAK,EAChCI,EAAeb,KAAKc,MAAMF,EAASrB,EAAMwB,OAASxB,EAAMG,QAE9DH,EAAMK,WAAY,EAClBhB,OAAOoC,OAAO,EAAGH,GAEbJ,GAAK,IACLlB,EAAME,OAASwB,sBAAsB,IAAMV,EAAcC,KA1CjEnB,SAASR,iBAAiB,SAAU,KAC5BU,EAAMK,UACNL,EAAMK,WAAY,GAItBsB,qBAAqB3B,EAAME,QAC3B0B,aAAa5B,EAAM6B,aAGnB7B,EAAMC,eAAiBkB,KAAKC,MAC5BpB,EAAMG,OAAS2B,YACf9B,EAAMwB,OAASlB,IAAoBK,wBAAwBC,EAC3DZ,EAAM6B,YAAcE,WAAWf,EAAezB,EAAOe,OACtD,CAAC0B,SAAS","file":"../src/js/anim-scroll.js","sourcesContent":["const initScrollAnimation = () => {\n    const delay = 400;\n    const duration = 300;\n\n    let sections = Array.prototype.slice.call(document.querySelectorAll('#js-fullpage > section'));\n\n    let state = {\n        lastScrollTime: -1,\n        lastAF: -1,\n        startY: -1,\n        currentTargetSection: null,\n        simulated: false\n    };\n\n\n    document.addEventListener('scroll', () => {\n        if (state.simulated) {\n            state.simulated = false;\n            return\n        }\n\n        cancelAnimationFrame(state.lastAF);\n        clearTimeout(state.lastTimeout);\n\n\n        state.lastScrollTime = Date.now();\n        state.startY = pageYOffset;\n        state.deltaY = getCurrentSection().getBoundingClientRect().y;\n        state.lastTimeout = setTimeout(animateScroll, delay, getCurrentSection())\n    }, {passive: true});\n\n    function getCurrentSection() {\n        let retEl = sections[0];\n        let min = Math.abs(retEl.getBoundingClientRect().y);\n        for (let i = 1; i < sections.length; i++) {\n            const distance = Math.abs(sections[i].getBoundingClientRect().y);\n            if (distance > min) {\n                return retEl\n            }\n            min = distance;\n            retEl = sections[i]\n        }\n        return retEl\n    }\n\n    function animateScroll(target) {\n        const spend = Date.now() - state.lastScrollTime - delay;\n\n        const t = spend / duration;\n\n        const curveY = 2 * (1 - t) * t + t ** 2;\n        const newScrollTop = Math.round(curveY * state.deltaY + state.startY);\n\n        state.simulated = true;\n        window.scroll(0, newScrollTop);\n\n        if (t <= 1)\n            state.lastAF = requestAnimationFrame(() => animateScroll(target))\n\n    }\n\n};\n\nwindow.addEventListener('load', initScrollAnimation);"]}